import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';


// API call for products
export const fetchProducts = createAsyncThunk('products/fetchProducts', async () => {
    try {
        const response = await axios.get('http://localhost:3001/products');
        return response.data;
    } catch (error) {
        throw new Error(`Failed to fetch products. Error message: ${error}` );
    }
  });

  // API call to create product
  export const addProduct = createAsyncThunk('products/addProduct', async (product, { dispatch }) => {
    try {
        const response = await axios.post('http://localhost:3001/products', product);
        dispatch(addProductSuccess(response.data));
    } catch (error) {
        throw new Error(`Failed to add product. Error message: ${error}`);
    }
  });


const productSlice = createSlice({
    name: 'products',
    initialState: {
        products: [],
        loading: false,
        error: null,
    },
    reducers: {
        addProductSuccess: (state, action) => {
            state.products.push(action.payload);
            //state.products = [...state.products, action.payload];
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchProducts.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(fetchProducts.fulfilled, (state, action) => {
                state.loading = false;
                state.products = action.payload;
            })
            .addCase(fetchProducts.rejected, (state, action) => {
                state.loading = false;
                state.error = action.error.message;
            })
            .addCase(addProduct.pending, (state) => {
                state.loading = true; 
                state.error = null;     
            })
            .addCase(addProduct.fulfilled, (state, action) => {
                state.loading = false;
                state.products.push(action.payload);
            })
            .addCase(addProduct.rejected, (state, action) => {
                state.loading = false;
                state.error = action.error.message;
            });
    },
});


export const { addProductSuccess } = productSlice.actions;
export default productSlice.reducer;



/*
******** NOTES:
reducers
The reducers property is used to define the primary reducer functions for the slice. 
These reducers handle synchronous state updates in response to actions that are automatically 
generated by createSlice. Each reducer function corresponds to an action type, and createSlice 
creates action creators for these actions.

* Purpose: Define the core logic for updating the slice's state in response to actions dispatched to this slice.

* Structure: An object where each key is the name of an action/reducer, and the value is a reducer function. 
The reducer function receives the current state and an action object (with payload if provided).

* Action Creators: createSlice automatically generates action creators for each reducer, named after the reducer keys.

* Usage: Use reducers for straightforward state updates that are internal to the slice.



extraReducers
The extraReducers property is used to handle actions that are not generated by the slice's own 
reducers. These can include:

* Actions from other slices (created by other createSlice calls).

* Async actions created with createAsyncThunk.

* Any other action types defined elsewhere in the app.

* Purpose: Allow the slice to respond to external actions or async operations, keeping the slice's reducer logic clean and modular.

* Structure: Can be an object or a builder function (using the builder API). Each key (or addCase/addMatcher) specifies an action type and its corresponding reducer logic.

* Action Creators: Not generated by extraReducers, as it responds to actions defined elsewhere.

* Usage: Use extraReducers for handling async thunks, cross-slice actions, or other external action types.




Best Practices
1. Use reducers for internal slice logic: Keep synchronous, slice-specific state updates in reducers.
2. Use extraReducers for external actions: Handle async thunks or actions from other slices in extraReducers.
3. Prefer the builder API for extraReducers: Itâ€™s more flexible and supports advanced features like addMatcher for matching multiple action types.
4. Leverage Immer: Both reducers and extraReducers use Immer, so you can write "mutating" code (e.g., state.value += 1) while Redux Toolkit ensures immutability.
5. Organize async logic with createAsyncThunk: Pair createAsyncThunk with extraReducers for clean async workflows.


Reference Site:
https://redux-toolkit.js.org/api/createslice


*/
